from _typeshed import Incomplete
from collections.abc import Generator
import asyncio

VERSION: tuple
ESP32: bool
RP2: bool
LINUX: bool
WIN32: bool
BUSY_ERRORS: list
LINK_DOWN_ERRORS: list
ESP8266: bool
PYBOARD: bool

class MsgQueue:
    discards: int
    def __init__(self, size:int) -> None: ...
    def put(self, *v) -> None: ...
    def __aiter__(self): ...
    async def __anext__(self): ...

config: dict[str, str|int|None]

class MQTTException(Exception): ...

def pid_gen() -> Generator[int]: ...
def qos_check(qos) -> None: ...

class MQTT_base:
    REPUB_COUNT: int
    DEBUG: bool
    up: asyncio.Event
    down: asyncio.Event
    queue: MsgQueue
    port: int
    server: str
    newpid: int
    rcv_pids: int
    last_rx: int
    lock: asyncio.Lock
    def __init__(self, config: dict[str, str|int|None]) -> None: ...
    def dprint(self, msg, *args) -> None: ...
    def resolve(self, host:str) -> bytearray: ...
    async def connect(self, clean: bool = True) -> None: ...
    async def broker_up(self) -> bool: ...
    async def disconnect(self) -> None: ...
    async def publish(self, topic, msg: bytes, retain: bool = False, qos: int = 0, oneshot: bool = False) -> None: ...
    async def subscribe(self, topic, qos: int = 0) -> None: ...
    async def unsubscribe(self, topic) -> None: ...
    def set_cb_on_event(self, evt, cb, new_task: bool = False, udata: Incomplete | None = None) -> None: ...
